var N = null;var searchIndex = {};
searchIndex["ropey"]={"doc":"Ropey is a utf8 text rope for Rust.  It is fast, robust, and can handle huge texts and memory-incoherent edits with ease.","items":[[3,"Rope","ropey","A utf8 text rope.",N,N],[3,"RopeBuilder","","An efficient incremental `Rope` builder.",N,N],[3,"RopeSlice","","An immutable view into part of a `Rope`.",N,N],[11,"new","","Creates an empty `Rope`.",0,[[],["self"]]],[11,"from_str","","Creates a `Rope` from a string slice.",0,[[["str"]],["self"]]],[11,"from_reader","","Creates a `Rope` from the output of a reader.",0,[[["t"]],["result"]]],[11,"write_to","","Writes the contents of the `Rope` to a writer.",0,[[["self"],["t"]],["result"]]],[11,"len_bytes","","Total number of bytes in the `Rope`.",0,[[["self"]],["usize"]]],[11,"len_chars","","Total number of chars in the `Rope`.",0,[[["self"]],["usize"]]],[11,"len_lines","","Total number of lines in the `Rope`.",0,[[["self"]],["usize"]]],[11,"capacity","","Total size of the `Rope`'s text buffer space, in bytes.",0,[[["self"]],["usize"]]],[11,"shrink_to_fit","","Shrinks the `Rope`'s capacity to the minimum possible.",0,[[["self"]]]],[11,"insert","","Inserts `text` at char index `char_idx`.",0,[[["self"],["usize"],["str"]]]],[11,"insert_char","","Inserts a single char `ch` at char index `char_idx`.",0,[[["self"],["usize"],["char"]]]],[11,"remove","","Removes the text in the given char index range.",0,[[["self"],["r"]]]],[11,"split_off","","Splits the `Rope` at `char_idx`, returning the right part of the split.",0,[[["self"],["usize"]],["self"]]],[11,"append","","Appends a `Rope` to the end of this one, consuming the other `Rope`.",0,[[["self"],["self"]]]],[11,"byte_to_char","","Returns the char index of the given byte.",0,[[["self"],["usize"]],["usize"]]],[11,"byte_to_line","","Returns the line index of the given byte.",0,[[["self"],["usize"]],["usize"]]],[11,"char_to_byte","","Returns the byte index of the given char.",0,[[["self"],["usize"]],["usize"]]],[11,"char_to_line","","Returns the line index of the given char.",0,[[["self"],["usize"]],["usize"]]],[11,"line_to_byte","","Returns the byte index of the start of the given line.",0,[[["self"],["usize"]],["usize"]]],[11,"line_to_char","","Returns the char index of the start of the given line.",0,[[["self"],["usize"]],["usize"]]],[11,"byte","","Returns the byte at `byte_idx`.",0,[[["self"],["usize"]],["u8"]]],[11,"char","","Returns the char at `char_idx`.",0,[[["self"],["usize"]],["char"]]],[11,"line","","Returns the line at `line_idx`.",0,[[["self"],["usize"]],["ropeslice"]]],[11,"chunk_at_byte","","Returns the chunk containing the given byte index.",0,N],[11,"chunk_at_char","","Returns the chunk containing the given char index.",0,N],[11,"chunk_at_line_break","","Returns the chunk containing the given line break.",0,N],[11,"slice","","Gets an immutable slice of the `Rope`.",0,[[["self"],["r"]],["ropeslice"]]],[11,"bytes","","Creates an iterator over the bytes of the `Rope`.",0,[[["self"]],["bytes"]]],[11,"chars","","Creates an iterator over the chars of the `Rope`.",0,[[["self"]],["chars"]]],[11,"lines","","Creates an iterator over the lines of the `Rope`.",0,[[["self"]],["lines"]]],[11,"chunks","","Creates an iterator over the chunks of the `Rope`.",0,[[["self"]],["chunks"]]],[11,"new","","Creates a new RopeBuilder, ready for input.",1,[[],["self"]]],[11,"append","","Appends `chunk` to the end of the in-progress `Rope`.",1,[[["self"],["str"]]]],[11,"finish","","Finishes the build, and returns the `Rope`.",1,[[["self"]],["rope"]]],[11,"len_bytes","","Total number of bytes in the `RopeSlice`.",2,[[["self"]],["usize"]]],[11,"len_chars","","Total number of chars in the `RopeSlice`.",2,[[["self"]],["usize"]]],[11,"len_lines","","Total number of lines in the `RopeSlice`.",2,[[["self"]],["usize"]]],[11,"byte_to_char","","Returns the char index of the given byte.",2,[[["self"],["usize"]],["usize"]]],[11,"byte_to_line","","Returns the line index of the given byte.",2,[[["self"],["usize"]],["usize"]]],[11,"char_to_byte","","Returns the byte index of the given char.",2,[[["self"],["usize"]],["usize"]]],[11,"char_to_line","","Returns the line index of the given char.",2,[[["self"],["usize"]],["usize"]]],[11,"line_to_byte","","Returns the byte index of the start of the given line.",2,[[["self"],["usize"]],["usize"]]],[11,"line_to_char","","Returns the char index of the start of the given line.",2,[[["self"],["usize"]],["usize"]]],[11,"byte","","Returns the byte at `byte_idx`.",2,[[["self"],["usize"]],["u8"]]],[11,"char","","Returns the char at `char_idx`.",2,[[["self"],["usize"]],["char"]]],[11,"line","","Returns the line at `line_idx`.",2,[[["self"],["usize"]],["ropeslice"]]],[11,"chunk_at_byte","","Returns the chunk containing the given byte index.",2,N],[11,"chunk_at_char","","Returns the chunk containing the given char index.",2,N],[11,"chunk_at_line_break","","Returns the chunk containing the given line break.",2,N],[11,"as_str","","Returns the entire contents of the `RopeSlice` as a `&str` if possible.",2,[[["self"]],["option",["str"]]]],[11,"slice","","Returns a sub-slice of the `RopeSlice` in the given char index range.",2,[[["self"],["r"]],["self"]]],[11,"bytes","","Creates an iterator over the bytes of the `RopeSlice`.",2,[[["self"]],["bytes"]]],[11,"chars","","Creates an iterator over the chars of the `RopeSlice`.",2,[[["self"]],["chars"]]],[11,"lines","","Creates an iterator over the lines of the `RopeSlice`.",2,[[["self"]],["lines"]]],[11,"chunks","","Creates an iterator over the chunks of the `RopeSlice`.",2,[[["self"]],["chunks"]]],[0,"iter","","Iterators over a `Rope`'s data.",N,N],[3,"Bytes","ropey::iter","An iterator over a `Rope`'s bytes.",N,N],[3,"Chars","","An iterator over a `Rope`'s chars.",N,N],[3,"Lines","","An iterator over a `Rope`'s lines.",N,N],[3,"Chunks","","An iterator over a `Rope`'s contiguous `str` chunks.",N,N],[0,"str_utils","ropey","Utility functions for utf8 string slices.",N,N],[5,"byte_to_char_idx","ropey::str_utils","Converts from byte-index to char-index in a string slice.",N,[[["str"],["usize"]],["usize"]]],[5,"byte_to_line_idx","","Converts from byte-index to line-index in a string slice.",N,[[["str"],["usize"]],["usize"]]],[5,"char_to_byte_idx","","Converts from char-index to byte-index in a string slice.",N,[[["str"],["usize"]],["usize"]]],[5,"char_to_line_idx","","Converts from char-index to line-index in a string slice.",N,[[["str"],["usize"]],["usize"]]],[5,"line_to_byte_idx","","Converts from line-index to byte-index in a string slice.",N,[[["str"],["usize"]],["usize"]]],[5,"line_to_char_idx","","Converts from line-index to char-index in a string slice.",N,[[["str"],["usize"]],["usize"]]],[11,"from","ropey","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_string","","",2,[[["self"]],["string"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","ropey::iter","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"into_iter","","",3,[[["self"]],["i"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"into_iter","","",4,[[["self"]],["i"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"into_iter","","",5,[[["self"]],["i"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"into_iter","","",6,[[["self"]],["i"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"clone","ropey","",0,[[["self"]],["rope"]]],[11,"clone","","",1,[[["self"]],["ropebuilder"]]],[11,"clone","","",2,[[["self"]],["ropeslice"]]],[11,"from","","",0,[[["str"]],["self"]]],[11,"from","","",0,[[["cow",["str"]]],["self"]]],[11,"from","","",0,[[["string"]],["self"]]],[11,"from","","",0,[[["ropeslice"]],["self"]]],[11,"from","","",2,[[["str"]],["self"]]],[11,"next","ropey::iter","",3,[[["self"]],["option",["u8"]]]],[11,"next","","",4,[[["self"]],["option",["char"]]]],[11,"next","","",5,[[["self"]],["option",["ropeslice"]]]],[11,"next","","",6,[[["self"]],["option",["str"]]]],[11,"partial_cmp","ropey","",0,[[["self"],["rope"]],["option",["ordering"]]]],[11,"partial_cmp","","",2,[[["self"],["ropeslice"]],["option",["ordering"]]]],[11,"default","","",0,[[],["self"]]],[11,"default","","",1,[[],["ropebuilder"]]],[11,"eq","","",0,[[["self"],["rope"]],["bool"]]],[11,"eq","","",0,[[["self"],["str"]],["bool"]]],[11,"eq","","",0,[[["self"],["str"]],["bool"]]],[11,"eq","","",0,[[["self"],["string"]],["bool"]]],[11,"eq","","",0,[[["self"],["cow"]],["bool"]]],[11,"eq","","",2,[[["self"],["ropeslice"]],["bool"]]],[11,"eq","","",2,[[["self"],["str"]],["bool"]]],[11,"eq","","",2,[[["self"],["str"]],["bool"]]],[11,"eq","","",2,[[["self"],["string"]],["bool"]]],[11,"eq","","",2,[[["self"],["cow"]],["bool"]]],[11,"eq","","",2,[[["self"],["rope"]],["bool"]]],[11,"eq","","",0,[[["self"],["ropeslice"]],["bool"]]],[11,"cmp","","",0,[[["self"],["rope"]],["ordering"]]],[11,"cmp","","",2,[[["self"],["ropeslice"]],["ordering"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"from_iter","","",0,[[["t"]],["self"]]],[11,"from_iter","","",0,[[["t"]],["self"]]],[11,"from_iter","","",0,[[["t"]],["self"]]]],"paths":[[3,"Rope"],[3,"RopeBuilder"],[3,"RopeSlice"],[3,"Bytes"],[3,"Chars"],[3,"Lines"],[3,"Chunks"]]};
searchIndex["smallvec"]={"doc":"Small vectors in various sizes. These store a certain number of elements inline, and fall back to the heap for larger allocations.  This can be a useful optimization for improving cache locality and reducing allocator traffic for workloads that fit within the inline buffer.","items":[[3,"Drain","smallvec","An iterator that removes the items from a `SmallVec` and yields them by value.",N,N],[3,"SmallVec","","A `Vec`-like container that can store a small number of elements inline.",N,N],[3,"IntoIter","","An iterator that consumes a `SmallVec` and yields its items by value.",N,N],[8,"VecLike","","Common operations implemented by both `Vec` and `SmallVec`.",N,N],[10,"push","","Append an element to the vector.",0,[[["self"],["t"]]]],[8,"ExtendFromSlice","","Trait to be implemented by a collection that can be extended from a slice",N,N],[10,"extend_from_slice","","Extends a collection from a slice of its element type",1,N],[8,"Array","","Types that can be used as the backing store for a SmallVec",N,N],[16,"Item","","The type of the array's elements.",2,N],[10,"size","","Returns the number of items the array can hold.",2,[[],["usize"]]],[10,"ptr","","Returns a pointer to the first element of the array.",2,N],[10,"ptr_mut","","Returns a mutable pointer to the first element of the array.",2,N],[11,"new","","Construct an empty vector",3,[[],["smallvec"]]],[11,"with_capacity","","Construct an empty vector with enough capacity pre-allocated to store at least `n` elements.",3,[[["usize"]],["self"]]],[11,"from_vec","","Construct a new `SmallVec` from a `Vec<A::Item>`.",3,[[["vec"]],["smallvec"]]],[11,"from_buf","","Constructs a new `SmallVec` on the stack from an `A` without copying elements.",3,[[["a"]],["smallvec"]]],[11,"from_buf_and_len","","Constructs a new `SmallVec` on the stack from an `A` without copying elements. Also sets the length, which must be less or equal to the size of `buf`.",3,[[["a"],["usize"]],["smallvec"]]],[11,"from_buf_and_len_unchecked","","Constructs a new `SmallVec` on the stack from an `A` without copying elements. Also sets the length. The user is responsible for ensuring that `len <= A::size()`.",3,[[["a"],["usize"]],["smallvec"]]],[11,"set_len","","Sets the length of a vector.",3,[[["self"],["usize"]]]],[11,"inline_size","","The maximum number of elements this vector can hold inline",3,[[["self"]],["usize"]]],[11,"len","","The number of elements stored in the vector",3,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the vector is empty",3,[[["self"]],["bool"]]],[11,"capacity","","The number of items the vector can hold without reallocating",3,[[["self"]],["usize"]]],[11,"spilled","","Returns `true` if the data has spilled into a separate heap-allocated buffer.",3,[[["self"]],["bool"]]],[11,"drain","","Empty the vector and return an iterator over its former contents.",3,[[["self"]],["drain"]]],[11,"push","","Append an item to the vector.",3,N],[11,"pop","","Remove an item from the end of the vector and return it, or None if empty.",3,[[["self"]],["option"]]],[11,"grow","","Re-allocate to set the capacity to `max(new_cap, inline_size())`.",3,[[["self"],["usize"]]]],[11,"reserve","","Reserve capacity for `additional` more elements to be inserted.",3,[[["self"],["usize"]]]],[11,"reserve_exact","","Reserve the minimum capacity for `additional` more elements to be inserted.",3,[[["self"],["usize"]]]],[11,"shrink_to_fit","","Shrink the capacity of the vector as much as possible.",3,[[["self"]]]],[11,"truncate","","Shorten the vector, keeping the first `len` elements and dropping the rest.",3,[[["self"],["usize"]]]],[11,"as_slice","","Extracts a slice containing the entire vector.",3,N],[11,"as_mut_slice","","Extracts a mutable slice of the entire vector.",3,N],[11,"swap_remove","","Remove the element at position `index`, replacing it with the last element.",3,N],[11,"clear","","Remove all elements from the vector.",3,[[["self"]]]],[11,"remove","","Remove and return the element at position `index`, shifting all elements after it to the left.",3,N],[11,"insert","","Insert an element at position `index`, shifting all elements after it to the right.",3,N],[11,"insert_many","","Insert multiple elements at position `index`, shifting all following elements toward the back.",3,[[["self"],["usize"],["i"]]]],[11,"into_vec","","Convert a SmallVec to a Vec, without reallocating if the SmallVec has already spilled onto the heap.",3,[[["self"]],["vec"]]],[11,"into_inner","","Convert the SmallVec into an `A` if possible. Otherwise return `Err(Self)`.",3,[[["self"]],["result"]]],[11,"retain","","Retains only the elements specified by the predicate.",3,[[["self"],["f"]]]],[11,"dedup","","Removes consecutive duplicate elements.",3,[[["self"]]]],[11,"dedup_by","","Removes consecutive duplicate elements using the given equality relation.",3,[[["self"],["f"]]]],[11,"dedup_by_key","","Removes consecutive elements that map to the same key.",3,[[["self"],["f"]]]],[11,"from_raw_parts","","Creates a `SmallVec` directly from the raw components of another `SmallVec`.",3,N],[11,"from_slice","","Copy the elements from a slice into a new `SmallVec`.",3,N],[11,"insert_from_slice","","Copy elements from a slice into the vector at position `index`, shifting any following elements toward the back.",3,N],[11,"extend_from_slice","","Copy elements from a slice and append them to the vector.",3,N],[11,"resize","","Resizes the vector so that its length is equal to `len`.",3,N],[11,"from_elem","","Creates a `SmallVec` with `n` copies of `elem`. ``` use smallvec::SmallVec;",3,N],[14,"smallvec","","Creates a [`SmallVec`] containing the arguments.",N,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"into_iter","","",4,[[["self"]],["i"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"into_iter","","",3,[[["self"]],["i"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"into_iter","","",5,[[["self"]],["i"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"push","","",3,N],[11,"extend_from_slice","","",3,N],[11,"clone","","",3,[[["self"]],["smallvec"]]],[11,"extend","","",3,[[["self"],["i"]]]],[11,"from","","",3,N],[11,"from","","",3,[[["vec"]],["smallvec"]]],[11,"from","","",3,[[["a"]],["smallvec"]]],[11,"drop","","",4,[[["self"]]]],[11,"drop","","",3,[[["self"]]]],[11,"drop","","",5,[[["self"]]]],[11,"next","","",4,[[["self"]],["option"]]],[11,"size_hint","","",4,N],[11,"next","","",5,[[["self"]],["option"]]],[11,"size_hint","","",5,N],[11,"as_ref","","",3,N],[11,"partial_cmp","","",3,[[["self"],["smallvec"]],["option",["ordering"]]]],[11,"default","","",3,[[],["smallvec"]]],[11,"as_mut","","",3,N],[11,"eq","","",3,[[["self"],["smallvec"]],["bool"]]],[11,"ne","","",3,[[["self"],["smallvec"]],["bool"]]],[11,"next_back","","",4,[[["self"]],["option"]]],[11,"next_back","","",5,[[["self"]],["option"]]],[11,"into_iter","","",3,N],[11,"cmp","","",3,[[["self"],["smallvec"]],["ordering"]]],[11,"hash","","",3,[[["self"],["h"]]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"deref","","",3,N],[11,"deref_mut","","",3,N],[11,"index","","",3,N],[11,"index","","",3,N],[11,"index","","",3,N],[11,"index","","",3,N],[11,"index","","",3,N],[11,"index_mut","","",3,N],[11,"index_mut","","",3,N],[11,"index_mut","","",3,N],[11,"index_mut","","",3,N],[11,"index_mut","","",3,N],[11,"from_iter","","",3,[[["i"]],["smallvec"]]],[11,"borrow","","",3,N],[11,"write","","",3,N],[11,"write_all","","",3,N],[11,"flush","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,N]],"paths":[[8,"VecLike"],[8,"ExtendFromSlice"],[8,"Array"],[3,"SmallVec"],[3,"Drain"],[3,"IntoIter"]]};
searchIndex["unreachable"]={"doc":"unreachable","items":[[5,"unreachable","unreachable","Hint to the optimizer that any code path which calls this function is statically unreachable and can be removed.",N,N],[8,"UncheckedOptionExt","","An extension trait for `Option<T>` providing unchecked unwrapping methods.",N,N],[10,"unchecked_unwrap","","Get the value out of this Option without checking for None.",0,[[["self"]],["t"]]],[10,"unchecked_unwrap_none","","Assert that this Option is a None to the optimizer.",0,[[["self"]]]],[8,"UncheckedResultExt","","An extension trait for `Result<T, E>` providing unchecked unwrapping methods.",N,N],[10,"unchecked_unwrap_ok","","Get the value out of this Result without checking for Err.",1,[[["self"]],["t"]]],[10,"unchecked_unwrap_err","","Get the error out of this Result without checking for Ok.",1,[[["self"]],["e"]]]],"paths":[[8,"UncheckedOptionExt"],[8,"UncheckedResultExt"]]};
searchIndex["void"]={"doc":"Void","items":[[4,"Void","void","The empty type for cases which can't occur.",N,N],[5,"unreachable","","A safe version of `intrinsincs::unreachable`.",N,N],[8,"ResultVoidExt","","Extensions to `Result<T, Void>`",N,N],[10,"void_unwrap","","Get the value out of a wrapper.",0,[[["self"]],["t"]]],[8,"ResultVoidErrExt","","Extensions to `Result<Void, E>`",N,N],[10,"void_unwrap_err","","Get the error out of a wrapper.",1,[[["self"]],["e"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"eq","","",2,[[["self"],["t"]],["bool"]]],[11,"partial_cmp","","",2,[[["self"],["t"]],["option",["ordering"]]]],[11,"clone","","",2,[[["self"]],["void"]]]],"paths":[[8,"ResultVoidExt"],[8,"ResultVoidErrExt"],[4,"Void"]]};
initSearch(searchIndex);
